-- @path game=/game/model/generated/Game.ecore
-- @path petri=/fr.n7.petriNet/PetriNet.ecore

module generatePetri;
create OUT : petri from IN : game;

-- Récupérer le jeu qui contient cet élément de jeu
helper context game!ElementsJeu
def: getJeu(): game!Jeu =
	game!Jeu.allInstances()
		->select(p | p.ElementsJeu->includes(self))
		->asSequence()->first();

-- Traduire un Jeu en un PetriNet de même nom
rule Jeu2PetriNet {
	from j: game!Jeu
	to 	pn: petri!PetriNet (name <- j.name),
	
		p_init: petri!Place(
			name <- j.name + '_init',
			currentToken <- 1,
			petrinet <- pn),
			
		t_start: petri!Transition(
			name <- 'start_' + j.name,
			petrinet <- pn),
		
		arc: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- p_init,
			transition <- t_start,
			petrinet <- pn)
}

-- Traduire un Lieu final
rule LieuFinal2PetriNet {
	from l: game!Lieu(l.nature=#fin)
	to 	p_init: petri!Place(
			name <- l.name + '_init',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'p_init'))
}

-- Traduire un Lieu de départ
rule LieuInitial2PetriNet {
	from l: game!Lieu(l.nature=#depart)
	to 	p_init: petri!Place(
			name <- l.name + '_init',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'p_init')),
		
		p_end: petri!Place(
			name <- l.name + '_end',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'p_init')),
		
		arc: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- p_init,
			transition <- thisModule.resolveTemp(l.getJeu(), 't_start'),
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'p_init'))
}

-- Traduire un Lieu intermédiaire
rule LieuInter2PetriNet {
	from l: game!Lieu(l.nature=#inter)
	to	p_init: petri!Place(
			name <- l.name + '_init',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'p_init')),
		
		p_end: petri!Place(
			name <- l.name + '_end',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'p_init')),
		
		p_inter: petri!Place(
			name <- l.name + '_inter',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'p_init')),
		
		t_inter: petri!Transition(
			name <- l.name,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'p_init')),
		
		a_interIn: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- p_inter,
			transition <- t_inter,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'p_init')),
		
		a_interOut: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- p_end,
			transition <- t_inter,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'p_init'))
}

-- Traduire un Chemin
rule Chemin2PetriNet {
	from ch: game!Chemin
	to 	tr: petri!Transition(
			name <- ch.name,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'p_init')),
			
		tr_initVisible: petri!Transition(
			name <- 'init_' + ch.name + '_visible',
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'p_init')),
			
		tr_initOuvert: petri!Transition(
			name <- 'init_' + ch.name + '_ouvert',
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'p_init')),
		
		p_ouvert: petri!Place(
			name <- ch.name + '_open',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'p_init')),
			
		p_visible: petri!Place(
			name <- ch.name + '_visible',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'p_init')),
			
		p_obligatoire: petri!Place(
			name <- ch.name + '_obligatoire',
			currentToken <- if ch.obligatoire then 1 else 0 endif,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'p_init')),
			
		a_vis: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- p_visible,
			transition <- tr_initVisible,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'p_init')),
			
		a_vis2: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- p_visible,
			transition <- tr,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'p_init')),
			
		a_ouv: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- p_ouvert,
			transition <- tr_initOuvert,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'p_init')),
		
		a_ouv2: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- p_ouvert,
			transition <- tr,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'p_init')),
		
		a_pred: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- thisModule.resolveTemp(ch.pred, 'p_end'),
			transition <- tr,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'p_init')),
			
		a_succ: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- thisModule.resolveTemp(ch.pred, 'p_init'),
			transition <- tr,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'p_init'))
}

-- Traduire une Personne obligatoire
rule Personne2PetriNet {
	from pers: game!Personne(pers.obligatoire)
	to 	t_initVisible: petri!Transition(
			name <- 'init_' + pers.name + '_visible',
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'p_init')),
			
		t_initActive: petri!Transition(
			name <- 'init_' + pers.name + '_active',
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'p_init')),
		
		p_visible: petri!Place(
			name <- pers.name + '_visible',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'p_init')),
		
		p_active: petri!Place(
			name <- pers.name + '_active',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'p_init')),
			
		p_oblig: petri!Place(
			name <- pers.name + '_oblig',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'p_init')),
		
		a_oblig: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- p_oblig,
			transition <- thisModule.resolveTemp(pers.place, 'p_inter'),
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'p_init')),
		
		a_vis: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- p_visible,
			transition <- t_initVisible,
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'p_init')),
		
		a_active: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- p_active,
			transition <- t_initActive,
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'p_init'))
}

-- Traduire une Interaction
rule Interaction2PetriNet {
	from i: game!Interaction
	to	t_start: petri!Transition(
			name <- 'start_' + i.name,
			petrinet <- thisModule.resolveTemp(i.getJeu(), 'p_init')),
		
		a_start: petri!Arc(
			linkType <- #read,
			weight <- 1,
			placeToTrans <- true,
			place <- thisModule.resolveTemp(i.place, 'p_init'),
			transition <- t_start,
			petrinet <- thisModule.resolveTemp(i.getJeu(), 'p_init')),
		
		a_startVis: petri!Arc(
			linkType <- #read,
			weight <- 1,
			placeToTrans <- true,
			place <- thisModule.resolveTemp(i.personne, 'p_visible'),
			transition <- t_start,
			petrinet <- thisModule.resolveTemp(i.getJeu(), 'p_init')),
		
		a_startAct: petri!Arc(
			linkType <- #read,
			weight <- 1,
			placeToTrans <- true,
			place <- thisModule.resolveTemp(i.personne, 'p_active'),
			transition <- t_start,
			petrinet <- thisModule.resolveTemp(i.getJeu(), 'p_init')),
			
		p_quest: petri!Place(
			name <- i.question,
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(i.getJeu(), 'p_init')),
		
		a_quest: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- p_quest,
			transition <- t_start,
			petrinet <- thisModule.resolveTemp(i.getJeu(), 'p_init'))
}

-- Traduire un Choix d'une personne obligatoire
rule ChoixOblig2PetriNet {
	from c: game!Choix(c.interaction.personne.obligatoire)
	to	t: petri!Transition(
			name <- c.reponse,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'p_init')),
	
		a_in: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- thisModule.resolveTemp(c.interaction, 'p_quest'),
			transition <- t,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'p_init')),
			
		a_out: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- if c.bonne then thisModule.resolveTemp(c.interaction.personne.place, 'p_inter') else thisModule.resolveTemp(c.interaction.personne.place, 'p_init') endif,
			transition <- t,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'p_init')),
		
		a_oblig: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- thisModule.resolveTemp(c.interaction.personne, 'p_oblig'),
			transition <- t,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'p_init'))
}

-- Traduire un Choix d'une personne non obligatoire
rule Choix2PetriNet {
	from c: game!Choix(not c.interaction.personne.obligatoire)
	to	t: petri!Transition(
			name <- c.reponse,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'p_init')),
	
		a_in: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- thisModule.resolveTemp(c.interaction, 'p_quest'),
			transition <- t,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'p_init')),
			
		a_out: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- if c.bonne then thisModule.resolveTemp(c.interaction.personne.place, 'p_inter') else thisModule.resolveTemp(c.interaction.personne.place, 'p_init') endif,
			transition <- t,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'p_init'))
}

-- Traduire une Condition
rule Condition2PetriNet {
	from c: game!Condition
	to
}

-- Traduire un Objet
rule Object2PetriNet {
	from o: game!Objet
	to	p_visible: petri!Place(
			name <- o.name + '_visible',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(o.getJeu(), 'p_init')),
			
		p_actif: petri!Place(
			name <- o.name + '_actif',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(o.getJeu(), 'p_init')),
			
		p_objet: petri!Place(
			name <- o.name,
			currentToken <- o.qte,
			petrinet <- thisModule.resolveTemp(o.getJeu(), 'p_init')),
		
		p_conso: petri!Place(
			name <- o.name + '_conso',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(o.getJeu(), 'p_init')),
		
		p_trans: petri!Place(
			name <- o.name + '_trans',
			currentToken <- if o.transformable then 1 else 0 endif,
			petrinet <- thisModule.resolveTemp(o.getJeu(), 'p_init'))
}

-- Traduire une Connaissance
rule Connaissance2PetriNet {
	from c: game!Connaissance
	to	p_visible: petri!Place(
			name <- c.name + '_visible',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'p_init')),
			
		p_active: petri!Place(
			name <- c.name + '_active',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'p_init')),
			
		p_presente: petri!Place(
			name <- c.name + '_presente',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'p_init')),
		
		p_absente: petri!Place(
			name <- c.name + '_absente',
			currentToken <- 1,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'p_init'))
}

-- Traduire un explorateur
rule Explorateur2PetriNet {
	from e: game!Explorateur
	to
}
