-- @path game=/game/model/generated/Game.ecore
-- @path petri=/fr.n7.petriNet/PetriNet.ecore

module generatePetri;
create OUT : petri from IN : game;

-- Récupérer le jeu qui contient cet élément de jeu
helper context game!ElementsJeu
def: getJeu(): game!Jeu =
	game!Jeu.allInstances()
		->select(p | p.elementsjeu->includes(self))
		->asSequence()->first();

-- Récupérer la personne qui contient cette condition
helper context game!ElementsJeu
def: getPersonne(): game!Personne =
	game!Personne.allInstances()
		->select(p | p.visible->includes(self))
		->asSequence()->first();

-- Récupérer le chemin qui contient cette condition
helper context game!ElementsJeu
def: getChemin(): game!Chemin =
	game!Chemin.allInstances()
		->select(c | c.visible->includes(self))
		->asSequence()->first();


-- Traduire un Jeu en un PetriNet de même nom
rule Jeu2PetriNet {
	from j: game!Jeu
	to 	pn: petri!PetriNet (name <- j.name),
	
		p_init: petri!Place(
			name <- 'Init',
			currentToken <- 1,
			petrinet <- pn),
			
		t_start: petri!Transition(
			name <- 'Start_' + j.name,
			petrinet <- pn),
		
		arc: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- p_init,
			transition <- t_start,
			petrinet <- pn),
		
		p_def: petri!Place(
			name <- 'Default',
			currentToken <- 1,
			petrinet <- pn),
		
		t_def: petri!Transition(
			name <- 't_def',
			petrinet <- pn)
}

-- Traduire un Lieu final
rule LieuFinal2PetriNet {
	from l: game!Lieu(l.nature=#fin)
	to 	p_init: petri!Place(
			name <- l.name,
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'pn'))
}

-- Traduire un Lieu de départ
rule LieuInitial2PetriNet {
	from l: game!Lieu(l.nature=#depart)
	to 	p_init: petri!Place(
			name <- l.name + '_init',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'pn')),
		
		p_end: petri!Place(
			name <- l.name + '_end',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'pn')),
		
		arc: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- p_init,
			transition <- thisModule.resolveTemp(l.getJeu(), 't_start'),
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'pn')),
		
		t_inter: petri!Transition(
			name <- 'finish_' + l.name,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'pn')),
		
		a_interOut: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- p_end,
			transition <- t_inter,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'pn'))
}

-- Traduire un Lieu intermédiaire
rule LieuInter2PetriNet {
	from l: game!Lieu(l.nature=#inter)
	to	p_init: petri!Place(
			name <- l.name + '_init',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'pn')),
		
		p_end: petri!Place(
			name <- l.name + '_end',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'pn')),
		
		t_inter: petri!Transition(
			name <- 'finish_' + l.name,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'pn')),
		
		a_interOut: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- p_end,
			transition <- t_inter,
			petrinet <- thisModule.resolveTemp(l.getJeu(), 'pn'))
}

-- Traduire un Chemin
rule Chemin2PetriNet {
	from ch: game!Chemin
	to 	tr: petri!Transition(
			name <- ch.name,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'pn')),
			
		t_initVisible: petri!Transition(
			name <- 'init_' + ch.name + '_visible',
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'pn')),
		
		a_visPred: petri!Arc(
			linkType <- #read,
			weight <- 1,
			placeToTrans <- true,
			place <- thisModule.resolveTemp(ch.pred, 'p_end'),
			transition <- t_initVisible,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'pn')),
	 	
		t_initOuvert: petri!Transition(
			name <- 'init_' + ch.name + '_ouvert',
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'pn')),
		
		a_ouvPred: petri!Arc(
			linkType <- #read,
			weight <- 1,
			placeToTrans <- true,
			place <- thisModule.resolveTemp(ch.pred, 'p_end'),
			transition <- t_initOuvert,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'pn')),
			
		p_ouvert: petri!Place(
			name <- ch.name + '_open',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'pn')),
			
		p_visible: petri!Place(
			name <- ch.name + '_visible',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'pn')),
			
		p_obligatoire: petri!Place(
			name <- ch.name + '_obligatoire',
			currentToken <- if ch.obligatoire then 1 else 0 endif,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'pn')),
			
		p_first: petri!Place(
			name <- ch.name + '_first',
			currentToken <- 1,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'pn')),
			
		a_first: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- p_first,
			transition <- tr,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'pn')),
			
		a_vis: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- p_visible,
			transition <- t_initVisible,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'pn')),
			
		a_vis2: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- p_visible,
			transition <- tr,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'pn')),
			
		a_ouv: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- p_ouvert,
			transition <- t_initOuvert,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'pn')),
		
		a_ouv2: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- p_ouvert,
			transition <- tr,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'pn')),
		
		a_pred: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- thisModule.resolveTemp(ch.pred, 'p_end'),
			transition <- tr,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'pn')),
			
		a_succ: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- thisModule.resolveTemp(ch.succ, 'p_init'),
			transition <- tr,
			petrinet <- thisModule.resolveTemp(ch.getJeu(), 'pn'))
}

-- Traduire une Personne obligatoire
rule Personne2PetriNet {
	from pers: game!Personne(pers.obligatoire)
	to 	t_initVisible: petri!Transition(
			name <- 'init_' + pers.name + '_visible',
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'pn')),
		
		a_visPred: petri!Arc(
			linkType <- #read,
			weight <- 1,
			placeToTrans <- true,
			place <- thisModule.resolveTemp(pers.place, 'p_init'),
			transition <- t_initVisible,
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'pn')),
			
		t_initActive: petri!Transition(
			name <- 'init_' + pers.name + '_active',
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'pn')),
		
		a_activePred: petri!Arc(
			linkType <- #read,
			weight <- 1,
			placeToTrans <- true,
			place <- thisModule.resolveTemp(pers.place, 'p_init'),
			transition <- t_initActive,
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'pn')),
			
		p_visible: petri!Place(
			name <- pers.name + '_visible',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'pn')),
		
		p_active: petri!Place(
			name <- pers.name + '_active',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'pn')),
			
		p_oblig: petri!Place(
			name <- pers.name + '_oblig',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'pn')),
		
		a_oblig: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- p_oblig,
			transition <- thisModule.resolveTemp(pers.place, 't_inter'),
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'pn')),
		
		a_vis: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- p_visible,
			transition <- t_initVisible,
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'pn')),
		
		a_active: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- p_active,
			transition <- t_initActive,
			petrinet <- thisModule.resolveTemp(pers.getJeu(), 'pn'))
}

--TODO : pers non obligatoire


-- Traduire une Interaction
rule Interaction2PetriNet {
	from i: game!Interaction
	to	t_start: petri!Transition(
			name <- 'start_' + i.name,
			petrinet <- thisModule.resolveTemp(i.getJeu(), 'pn')),
		
		a_start: petri!Arc(
			linkType <- #read,
			weight <- 1,
			placeToTrans <- true,
			place <- thisModule.resolveTemp(i.personne.place, 'p_init'),
			transition <- t_start,
			petrinet <- thisModule.resolveTemp(i.getJeu(), 'pn')),
		
		a_startVis: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- thisModule.resolveTemp(i.personne, 'p_visible'),
			transition <- t_start,
			petrinet <- thisModule.resolveTemp(i.getJeu(), 'pn')),
		
		a_startAct: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- thisModule.resolveTemp(i.personne, 'p_active'),
			transition <- t_start,
			petrinet <- thisModule.resolveTemp(i.getJeu(), 'pn')),
			
		p_quest: petri!Place(
			name <- i.question,
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(i.getJeu(), 'pn')),
		
		a_quest: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- p_quest,
			transition <- t_start,
			petrinet <- thisModule.resolveTemp(i.getJeu(), 'pn'))
}

-- Traduire un Choix d'une personne obligatoire
rule ChoixOblig2PetriNet {
	from c: game!Choix(c.interaction.personne.obligatoire)
	to	t: petri!Transition(
			name <- c.reponse,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
	
		a_in: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- thisModule.resolveTemp(c.interaction, 'p_quest'),
			transition <- t,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
			
		a_out: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- if c.bonne then thisModule.resolveTemp(c.getJeu(), 'p_def') else thisModule.resolveTemp(c.interaction.personne.place, 'p_init') endif,
			transition <- t,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
		
		a_oblig: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- thisModule.resolveTemp(c.interaction.personne, 'p_oblig'),
			transition <- t,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn'))
}

-- Traduire un Choix d'une personne non obligatoire
rule Choix2PetriNet {
	from c: game!Choix(not c.interaction.personne.obligatoire)
	to	t: petri!Transition(
			name <- c.reponse,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
	
		a_in: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- thisModule.resolveTemp(c.interaction, 'p_quest'),
			transition <- t,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
			
		a_out: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- if c.bonne then thisModule.resolveTemp(c.interaction.personne.place, 'p_inter') else thisModule.resolveTemp(c.interaction.personne.place, 'p_init') endif,
			transition <- t,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn'))
}

-- Traduire un Objet
rule Object2PetriNet {
	from o: game!Objet
	to	p_visible: petri!Place(
			name <- o.name + '_visible',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(o.getJeu(), 'pn')),
			
		p_actif: petri!Place(
			name <- o.name + '_actif',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(o.getJeu(), 'pn')),
			
		p_objet: petri!Place(
			name <- o.name,
			currentToken <- o.qte,
			petrinet <- thisModule.resolveTemp(o.getJeu(), 'pn')),
		
		p_conso: petri!Place(
			name <- o.name + '_conso',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(o.getJeu(), 'pn')),
		
		p_trans: petri!Place(
			name <- o.name + '_trans',
			currentToken <- if o.transformable then 1 else 0 endif,
			petrinet <- thisModule.resolveTemp(o.getJeu(), 'pn'))
}

-- Traduire une QteObjet
rule QteObjet2PetriNet {
	from qo: game!QteObjet(not qo.objet.oclIsUndefined())
	to 	a: petri!Arc(
		linkType <- #take,
		weight <- qo.qte,
		placeToTrans <- if not qo.choixCons.oclIsUndefined() then true else false endif,
		place <- thisModule.resolveTemp(qo.objet, 'p_objet'),
		transition <- if not qo.choixCons.oclIsUndefined() then thisModule.resolveTemp(qo.choixCons, 't') else thisModule.resolveTemp(qo.choixDon, 't') endif,
		petrinet <- thisModule.resolveTemp(qo.getJeu(), 'pn'))
}

-- Traduire une Condition personne, visible
rule ConditionPersonneVisible2PetriNet {
	from c: game!ConditionPersonne(not c.visible.oclIsUndefined())
	to	p_def: petri!Place(
			name <- c.name + '_def',
			currentToken <- 1,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
		
		aOR: petri!Arc(
			linkType <- if not c.objetRequis.oclIsUndefined() then #read else #stopwatch endif,
			weight <- 1,
			placeToTrans <- true,
			place <- if not c.objetRequis.oclIsUndefined() then thisModule.resolveTemp(c.objetRequis, 'p_objet') else p_def endif,
			transition <- thisModule.resolveTemp(c.getPersonne(), 't_initVisible'),
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
			
		aCR: petri!Arc(
			linkType <- if not c.connaissanceRequise.oclIsUndefined() then #read else #stopwatch endif,
			weight <- 1,
			placeToTrans <- true,
			place <- if not c.connaissanceRequise.oclIsUndefined() then thisModule.resolveTemp(c.connaissanceRequise, 'p_presente') else p_def endif,
			transition <- thisModule.resolveTemp(c.getPersonne(), 't_initVisible'),
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
			
		aOI: petri!Arc(
			linkType <- if not c.objetInterdit.oclIsUndefined() then #inhibitor else #stopwatch endif,
			weight <- 1,
			placeToTrans <- true,
			place <- if not c.objetInterdit.oclIsUndefined() then thisModule.resolveTemp(c.objetInterdit, 'p_objet') else p_def endif,
			transition <- thisModule.resolveTemp(c.getPersonne(), 't_initVisible'),
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
			
		aCI: petri!Arc(
			linkType <- if not c.connaissanceInterdite.oclIsUndefined() then #read else #stopwatch endif,
			weight <- 1,
			placeToTrans <- true,
			place <- if not c.connaissanceInterdite.oclIsUndefined() then thisModule.resolveTemp(c.connaissanceInterdite, 'p_absente') else p_def endif,
			transition <- thisModule.resolveTemp(c.getPersonne(), 't_initVisible'),
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn'))
}

-- Traduire une Condition chemin, visible
rule ConditionCheminVisible2PetriNet {
	from c: game!ConditionChemin(not c.visible.oclIsUndefined())
	to	p_def: petri!Place(
			name <- c.name + '_def',
			currentToken <- 1,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
		
		aOR: petri!Arc(
			linkType <- if not c.objetRequis.oclIsUndefined() then #read else #stopwatch endif,
			weight <- if not c.objetRequis.oclIsUndefined() then c.objetRequis.qte else 1 endif,
			placeToTrans <- true,
			place <- if not c.objetRequis.oclIsUndefined() then thisModule.resolveTemp(c.objetRequis, 'p_objet') else p_def endif,
			transition <- thisModule.resolveTemp(c.getChemin(), 't_initVisible'),
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
			
		aCR: petri!Arc(
			linkType <- if not c.connaissanceRequise.oclIsUndefined() then #read else #stopwatch endif,
			weight <- 1,
			placeToTrans <- true,
			place <- if not c.connaissanceRequise.oclIsUndefined() then thisModule.resolveTemp(c.connaissanceRequise, 'p_presente') else p_def endif,
			transition <- thisModule.resolveTemp(c.getChemin(), 't_initVisible'),
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
			
		aOI: petri!Arc(
			linkType <- if not c.objetInterdit.oclIsUndefined() then #inhibitor else #stopwatch endif,
			weight <- 1,
			placeToTrans <- true,
			place <- if not c.objetInterdit.oclIsUndefined() then thisModule.resolveTemp(c.objetInterdit, 'p_objet') else p_def endif,
			transition <- thisModule.resolveTemp(c.getChemin(), 't_initVisible'),
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
			
		aCI: petri!Arc(
			linkType <- if not c.connaissanceInterdite.oclIsUndefined() then #read else #stopwatch endif,
			weight <- 1,
			placeToTrans <- true,
			place <- if not c.connaissanceInterdite.oclIsUndefined() then thisModule.resolveTemp(c.connaissanceInterdite, 'p_absente') else p_def endif,
			transition <- thisModule.resolveTemp(c.getChemin(), 't_initVisible'),
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn'))
}


--TODO : conditions pour visible sur avantage et toutes conditions pour actif / ouvert


-- Traduire une Connaissance
rule Connaissance2PetriNet {
	from c: game!Connaissance
	to	p_visible: petri!Place(
			name <- c.name + '_visible',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
			
		p_active: petri!Place(
			name <- c.name + '_active',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
			
		p_presente: petri!Place(
			name <- c.name + '_presente',
			currentToken <- 0,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
		
		p_absente: petri!Place(
			name <- c.name + '_absente',
			currentToken <- 1,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
		
		aIn: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- true,
			place <- p_absente,
			transition <- if not c.choix.oclIsUndefined() then thisModule.resolveTemp(c.choix, 't') else thisModule.resolveTemp(c.getJeu(), 't_def') endif,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn')),
		
		aOut: petri!Arc(
			linkType <- #take,
			weight <- 1,
			placeToTrans <- false,
			place <- if not c.choix.oclIsUndefined() then p_presente else p_absente endif,
			transition <- if not c.choix.oclIsUndefined() then thisModule.resolveTemp(c.choix, 't') else thisModule.resolveTemp(c.getJeu(), 't_def') endif,
			petrinet <- thisModule.resolveTemp(c.getJeu(), 'pn'))
}

--TODO : boucle for sur les objets et connaissances de l'explorateur pour 
-- changer les tokens des places correspondantes
-- Traduire un explorateur
rule Explorateur2PetriNet {
	from e: game!Explorateur
	to	
}
